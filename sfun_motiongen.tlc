%% Abstract:
%%      Tlc file for S-function sfun_motiongen.cpp

%implements "sfun_motiongen" "C"

%% Function: BlockTypeSetup ====================================================
%function BlockTypeSetup(block, system) void
  %%
  %% The Target Language must be C++
  %if ::GenCPP==0 && !IsModelReferenceSimTarget()
    %<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C++ Target Language")>
  %endif

  %<LibAddToCommonIncludes("<ruckig/ruckig.hpp>")>

  %<LibAddToModelSources("brake")>
  %<LibAddToModelSources("position_first_step1")>
  %<LibAddToModelSources("position_first_step2.")>
  %<LibAddToModelSources("position_second_step1")>
  %<LibAddToModelSources("position_second_step2")>
  %<LibAddToModelSources("position_third_step1")>
  %<LibAddToModelSources("position_third_step2")>
  %<LibAddToModelSources("velocity_second_step1")>
  %<LibAddToModelSources("velocity_second_step2")>
  %<LibAddToModelSources("velocity_third_step1")>
  %<LibAddToModelSources("velocity_third_step2")>
%endfunction


%% Function: mdlInitializeConditions ========================================
%% Abstract:
%%    In this function, you should initialize the continuous and discrete
%%    states for your S-function block.  The initial states are placed
%%    in the state vector, ssGetContStates(S) or ssGetRealDiscStates(S).
%%    You can also perform any other initialization activities that your
%%    S-function may require. Note, this routine will be called at the
%%    start of simulation and if it is present in an enabled subsystem
%%    configured to reset states, it will be call when the enabled
%%    subsystem restarts execution to reset the states.
%function InitializeConditions(block, system) Output
  /* %<Type> Block: %<Name> */
  {
    %% The mdlInitializeConditions method is called when the simulation
    %% start and every time an enabled subsystem is re-enabled.

    %% Reset the IWork flag to 1 when values need to be reinitialized.
    %<LibBlockPWork(BlockInit, "", "", 0)> = 1;
  }
%endfunction


%% Function: mdlStart =======================================================
%% Abstract:
%%   This function is called once at start of model execution. If you have
%%   states that should be initialized once, this is the place to do it.
%function Start(block, system) Output
  /* %<Type> Block: %<Name> */
  {
    %% Create instances: the Ruckig OTG as well as input and output parameters
    const unsigned int ndofs = static_cast<unsigned int>(%<SFcnParamSettings.NumberOfDoFs>);
    auto *OTG = new ruckig::Ruckig<ruckig::DynamicDOFs>( ndofs, %<SFcnParamSettings.SampleTime> );
    auto *IP  = new ruckig::InputParameter<ruckig::DynamicDOFs>( ndofs );
    auto *OP  = new ruckig::OutputParameter<ruckig::DynamicDOFs>( ndofs );
    
    const char* control = %<SFcnParamSettings.ControlInterface>;
    if (strcmp(control,"POSITION") == 0){
        IP->control_interface = ruckig::ControlInterface::Position;
    }
    else if (strcmp(control,"VELOCITY") == 0){
        IP->control_interface = ruckig::ControlInterface::Velocity;
    }
    else {
        IP->control_interface = ruckig::ControlInterface::Position;
    }
    
    const char* sync = %<SFcnParamSettings.Synchronization>;
    if (strcmp(sync,"NO_SYNCHRONIZATION") == 0){
        IP->synchronization = ruckig::Synchronization::None;
    }
    else if (strcmp(sync,"TIME_SYNCHRONIZATION_IF_NECESSARY") == 0){
        IP->synchronization = ruckig::Synchronization::TimeIfNecessary;
    }
    else if (strcmp(sync,"ONLY_TIME_SYNCHRONIZATION") == 0){
        IP->synchronization = ruckig::Synchronization::Time;
    }
    else if (strcmp(sync,"ONLY_PHASE_SYNCHRONIZATION") == 0){
        IP->synchronization = ruckig::Synchronization::Phase;
    }
    else {
        IP->synchronization = ruckig::Synchronization::Time;
    }
    
    const char* duration = %<SFcnParamSettings.DurationDiscretization>;
    if (strcmp(duration,"CONTINUOUS") == 0){
        IP->duration_discretization = ruckig::DurationDiscretization::Continuous;
    }
    else if (strcmp(duration,"DISCRETE") == 0){
        IP->duration_discretization = ruckig::DurationDiscretization::Discrete;
    }
    else {
        IP->duration_discretization = ruckig::DurationDiscretization::Continuous;
    }

    %% Store new C++ object in the pointers vector
    %<LibBlockPWork(Ruckig, "", "", 0)> = OTG;
    %<LibBlockPWork(InputParameter, "", "", 0)> = IP;
    %<LibBlockPWork(OutputParameter, "", "", 0)> = OP;
  }
%endfunction


%% Function: mdlOutputs =======================================================
%% Abstract:
%%   In this function, you compute the outputs of your S-function block.
%function Outputs(block, system) Output
  /* %<Type> Block: %<Name> */
  {
    %% Initialize values if the IWork vector flag is true. 
    if (%<LibBlockPWork(BlockInit, "", "", 0)> == 1) {
        const int_T ndofs = static_cast<int_T>(%<SFcnParamSettings.NumberOfDoFs>);
        for (int_T dof=0; dof < ndofs; dof++)
        {
            (%<LibBlockOutputSignalAddr(0, "", "", 0)>)[dof] = (%<LibBlockInputSignalAddr(3, "", "", 0)>)[dof];
            (%<LibBlockOutputSignalAddr(1, "", "", 0)>)[dof] = (%<LibBlockInputSignalAddr(4, "", "", 0)>)[dof];
            (%<LibBlockOutputSignalAddr(2, "", "", 0)>)[dof] = (%<LibBlockInputSignalAddr(5, "", "", 0)>)[dof];
        }

        %<LibBlockPWork(BlockInit, "", "", 0)> = 0;
    }
    else {
        %% Retrieve C++ object from the pointers vector
        auto *OP = static_cast<ruckig::OutputParameter<ruckig::DynamicDOFs> *>(%<LibBlockPWork(RMLPositionOutputParameters, "", "", 0)>);
    
        const int_T ndofs = static_cast<int_T>(%<SFcnParamSettings.NumberOfDoFs>);
        for (int_T dof=0; dof < ndofs; dof++)
        {
            (%<LibBlockOutputSignalAddr(0, "", "", 0)>)[dof] = OP->new_position[dof];
            (%<LibBlockOutputSignalAddr(1, "", "", 0)>)[dof] = OP->new_velocity[dof];
            (%<LibBlockOutputSignalAddr(2, "", "", 0)>)[dof] = OP->new_acceleration[dof];
        }
    }
  }
%endfunction


%% Function: mdlUpdate ======================================================
%% Abstract:
%%    This function is called once for every major integration time step.
%%    Discrete states are typically updated here, but this function is
%%    useful for performing any tasks that should only take place once per
%%    integration step.
%function Update(block, system) Output
  /* %<Type> Block: %<Name> */
  {
    %% Retrieve C++ object from the pointers vector
    auto *OTG   = static_cast<ruckig::Ruckig<ruckig::DynamicDOFs> *>(%<LibBlockPWork(Ruckig, "", "", 0)>);
    auto *IP    = static_cast<ruckig::InputParameter<ruckig::DynamicDOFs> *>(%<LibBlockPWork(InputParameter, "", "", 0)>);
    auto *OP    = static_cast<ruckig::OutputParameter<ruckig::DynamicDOFs> *>(%<LibBlockPWork(OutputParameter, "", "", 0)>);
    
    %% Set-up the input parameters
    const int_T ndofs = static_cast<int_T>(%<SFcnParamSettings.NumberOfDoFs>);
    for (int_T dof=0; dof < ndofs; dof++)
    {
        IP->current_position[dof]               = (%<LibBlockInputSignalAddr(3, "", "", 0)>)[dof];
        IP->current_velocity[dof]               = (%<LibBlockInputSignalAddr(4, "", "", 0)>)[dof];
        IP->current_acceleration[dof]           = (%<LibBlockInputSignalAddr(5, "", "", 0)>)[dof];
        IP->max_velocity[dof]                   = (%<LibBlockParameterAddr(VelLimit, "", "", 0)>)[dof];
        IP->max_acceleration[dof]               = (%<LibBlockParameterAddr(AccLimit, "", "", 0)>)[dof];
        IP->max_jerk[dof]                       = (%<LibBlockParameterAddr(JrkLimit, "", "", 0)>)[dof];
        IP->target_position[dof]                = (%<LibBlockInputSignalAddr(0, "", "", 0)>)[dof];
        IP->target_velocity[dof]                = (%<LibBlockInputSignalAddr(1, "", "", 0)>)[dof];
        IP->target_acceleration[dof]            = (%<LibBlockInputSignalAddr(2, "", "", 0)>)[dof];
    }
    
    %% Calling the Ruckig OTG algorithm
    int_T ResultValue = OTG->update(*IP,*OP);
  }
%endfunction


%% Function: mdlTerminate =====================================================
%% Abstract:
%%   In this function, you should perform any actions that are necessary
%%   at the termination of a simulation.  For example, if memory was
%%   allocated in mdlStart, this is the place to free it.
%function Terminate(block, system) Output
  /* %<Type> Block: %<Name> */
  {
    %% Retrieve C++ object from the pointers vector
    auto *OTG   = static_cast<ruckig::Ruckig<ruckig::DynamicDOFs> *>(%<LibBlockPWork(Ruckig, "", "", 0)>);
    auto *IP    = static_cast<ruckig::InputParameter<ruckig::DynamicDOFs> *>(%<LibBlockPWork(InputParameter, "", "", 0)>);
    auto *OP    = static_cast<ruckig::OutputParameter<ruckig::DynamicDOFs> *>(%<LibBlockPWork(OutputParameter, "", "", 0)>);
    
    %% Deleting the objects of the Ruckig Library end terminating the process
    delete  OTG;
    delete  IP;
    delete  OP;
  }
%endfunction